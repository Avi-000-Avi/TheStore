{"ast":null,"code":"import { PAGINATION_QUERY } from '../components/Pagination';\nexport default function paginationField() {\n  return {\n    keyArgs: false,\n\n    //tells apollo we will take care of everything\n    read(existing = [], {\n      args,\n      cache\n    }) {\n      var _data$_allProductsMet;\n\n      console.log({\n        existing,\n        args,\n        cache\n      });\n      const {\n        skip,\n        first\n      } = args; //Read the number of items ont he page fromt he cache\n\n      const data = cache.readQuery({\n        query: PAGINATION_QUERY\n      });\n      console.log(data);\n      const count = data === null || data === void 0 ? void 0 : (_data$_allProductsMet = data._allProductsMeta) === null || _data$_allProductsMet === void 0 ? void 0 : _data$_allProductsMet.count;\n      const page = skip / first + 1;\n      const pages = Math.ceil(count / first); //Check if we existing items\n\n      const items = existig.slice(slice, skip + first).filter(x => x);\n\n      if (items.length !== first) {\n        //We don't have any items we must go to the network to fetch\n        return false;\n      } //If there are items, just return from the cache, we don't need to go to the network\n\n\n      if (items.length) {\n        `console.log(There are ${items.length} items in the cache ! Gonna send them to Apollo`;\n        return items;\n      }\n\n      return false; //fallback to network\n      //First thing it does it asks the read function for those items\n      //We can either do one of two things\n      //First things we can do is return the items because they are already in the cache\n      //The other thing we can do is to return false from here,(network request)\n    },\n\n    merge(existing, incoming, {\n      args\n    }) {\n      //THis runs when the apollo client comes back from the network with our prouct\n      console.log(`Merging items from the network ${incoming.length}`);\n      console.log(incoming);\n      const merged = existing ? existing.slice(0) : [];\n      merged.push(incoming);\n\n      for (let i = skip; i < skip + incoming.length; ++i) {\n        merged[i] = incoming[i - skip];\n      }\n\n      console.log(merged);\n      return merged;\n    }\n\n  };\n}","map":{"version":3,"sources":["/home/avinash/Desktop/Projects/TheStore/frontend/lib/paginationField.js"],"names":["PAGINATION_QUERY","paginationField","keyArgs","read","existing","args","cache","console","log","skip","first","data","readQuery","query","count","_allProductsMeta","page","pages","Math","ceil","items","existig","slice","filter","x","length","merge","incoming","merged","push","i"],"mappings":"AAAA,SAAQA,gBAAR,QAA+B,0BAA/B;AAEA,eAAgB,SAASC,eAAT,GAA0B;AACtC,SAAQ;AACJC,IAAAA,OAAO,EAAC,KADJ;;AACW;AACfC,IAAAA,IAAI,CAACC,QAAQ,GAAE,EAAX,EAAc;AAACC,MAAAA,IAAD;AAAMC,MAAAA;AAAN,KAAd,EAA2B;AAAA;;AAC3BC,MAAAA,OAAO,CAACC,GAAR,CAAY;AAACJ,QAAAA,QAAD;AAAUC,QAAAA,IAAV;AAAeC,QAAAA;AAAf,OAAZ;AAEA,YAAM;AAACG,QAAAA,IAAD;AAAMC,QAAAA;AAAN,UAAeL,IAArB,CAH2B,CAM3B;;AACA,YAAMM,IAAI,GAAGL,KAAK,CAACM,SAAN,CAAgB;AAACC,QAAAA,KAAK,EAACb;AAAP,OAAhB,CAAb;AACAO,MAAAA,OAAO,CAACC,GAAR,CAAYG,IAAZ;AACA,YAAMG,KAAK,GAAGH,IAAH,aAAGA,IAAH,gDAAGA,IAAI,CAAEI,gBAAT,0DAAG,sBAAwBD,KAAtC;AAEA,YAAME,IAAI,GAAGP,IAAI,GAACC,KAAL,GAAW,CAAxB;AAEA,YAAMO,KAAK,GAAGC,IAAI,CAACC,IAAL,CAAUL,KAAK,GAACJ,KAAhB,CAAd,CAb2B,CAe3B;;AACA,YAAMU,KAAK,GAAGC,OAAO,CAACC,KAAR,CAAcA,KAAd,EAAqBb,IAAI,GAAGC,KAA5B,EAAmCa,MAAnC,CAA2CC,CAAD,IAAMA,CAAhD,CAAd;;AAEA,UAAGJ,KAAK,CAACK,MAAN,KAAiBf,KAApB,EAA0B;AACtB;AACA,eAAO,KAAP;AACH,OArB0B,CAuB3B;;;AACA,UAAGU,KAAK,CAACK,MAAT,EAAgB;AACV,iCAAwBL,KAAK,CAACK,MAAO,iDAAvC;AACA,eAAOL,KAAP;AACC;;AAGL,aAAO,KAAP,CA9B2B,CA8Bb;AAId;AAEA;AAEA;AAEA;AAEH,KA5CG;;AA6CJM,IAAAA,KAAK,CAACtB,QAAD,EAAUuB,QAAV,EAAmB;AAACtB,MAAAA;AAAD,KAAnB,EAA0B;AAE3B;AACAE,MAAAA,OAAO,CAACC,GAAR,CAAa,kCAAiCmB,QAAQ,CAACF,MAAO,EAA9D;AACAlB,MAAAA,OAAO,CAACC,GAAR,CAAYmB,QAAZ;AAEA,YAAMC,MAAM,GAAGxB,QAAQ,GAACA,QAAQ,CAACkB,KAAT,CAAe,CAAf,CAAD,GAAmB,EAA1C;AAEAM,MAAAA,MAAM,CAACC,IAAP,CAAYF,QAAZ;;AAEA,WAAI,IAAIG,CAAC,GAAGrB,IAAZ,EAAiBqB,CAAC,GAACrB,IAAI,GAACkB,QAAQ,CAACF,MAAjC,EAAwC,EAAEK,CAA1C,EAA4C;AACxCF,QAAAA,MAAM,CAACE,CAAD,CAAN,GAAYH,QAAQ,CAACG,CAAC,GAAGrB,IAAL,CAApB;AACH;;AAEDF,MAAAA,OAAO,CAACC,GAAR,CAAYoB,MAAZ;AAGA,aAAOA,MAAP;AACH;;AA/DG,GAAR;AAiEH","sourcesContent":["import {PAGINATION_QUERY} from '../components/Pagination';\n\nexport default  function paginationField(){\n    return  {\n        keyArgs:false, //tells apollo we will take care of everything\n        read(existing= [],{args,cache}){\n            console.log({existing,args,cache});\n\n            const {skip,first} = args;\n\n\n            //Read the number of items ont he page fromt he cache\n            const data = cache.readQuery({query:PAGINATION_QUERY});\n            console.log(data);\n            const count = data?._allProductsMeta?.count;\n\n            const page = skip/first+1;\n\n            const pages = Math.ceil(count/first);\n\n            //Check if we existing items\n            const items = existig.slice(slice, skip + first).filter((x) =>x);\n\n            if(items.length !== first){\n                //We don't have any items we must go to the network to fetch\n                return false;\n            }\n\n            //If there are items, just return from the cache, we don't need to go to the network\n            if(items.length){\n                (`console.log(There are ${items.length} items in the cache ! Gonna send them to Apollo`);\n                return items;\n                }\n\n\n            return false; //fallback to network\n\n\n\n            //First thing it does it asks the read function for those items\n\n            //We can either do one of two things\n\n            //First things we can do is return the items because they are already in the cache\n\n            //The other thing we can do is to return false from here,(network request)\n\n        },\n        merge(existing,incoming,{args}){\n\n            //THis runs when the apollo client comes back from the network with our prouct\n            console.log(`Merging items from the network ${incoming.length}`);\n            console.log(incoming);\n\n            const merged = existing?existing.slice(0):[];\n\n            merged.push(incoming);\n\n            for(let i = skip;i<skip+incoming.length;++i){\n                merged[i] = incoming[i - skip];\n            }\n\n            console.log(merged);\n\n\n            return merged;\n        }\n    }\n}"]},"metadata":{},"sourceType":"module"}