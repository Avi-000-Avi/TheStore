{"ast":null,"code":"import { PAGINATION_QUERY } from '../components/Pagination';\nexport default function paginationField() {\n  return {\n    keyArgs: false,\n\n    //tells apollo we will take care of everything\n    read(existing = [], {\n      args,\n      cache\n    }) {\n      var _data$_allProductsMet;\n\n      console.log({\n        existing,\n        args,\n        cache\n      });\n      const {\n        skip,\n        first\n      } = args; //Read the number of items on the page fromt he cache\n\n      const data = cache.readQuery({\n        query: PAGINATION_QUERY\n      });\n      console.log(data);\n      const count = data === null || data === void 0 ? void 0 : (_data$_allProductsMet = data._allProductsMeta) === null || _data$_allProductsMet === void 0 ? void 0 : _data$_allProductsMet.count;\n      const page = skip / first + 1;\n      const pages = Math.ceil(count / first); //Check if we existing items\n\n      const items = existing.slice(pages, skip + first).filter(x => x); //if there are items\n      //and there are'nt enough items to satisfy how many were requested\n      //ANd we are on the last page\n      //Then just send it\n\n      if (items.length && items.length !== first && page == pages) {\n        return items;\n      }\n\n      if (items.length !== first) {\n        //We don't have any items we must go to the network to fetch\n        return false;\n      } //If there are items, just return from the cache, we don't need to go to the network\n\n\n      if (items.length) {\n        `console.log(There are ${items.length} items in the cache ! Gonna send them to Apollo`;\n        return items;\n      }\n\n      return false; //fallback to network\n      //First thing it does it asks the read function for those items\n      //We can either do one of two things\n      //First things we can do is return the items because they are already in the cache\n      //The other thing we can do is to return false from here,(network request)\n    },\n\n    merge(existing, incoming, {\n      args\n    }) {\n      const {\n        skip,\n        first\n      } = args; //THis runs when the apollo client comes back from the network with our prouct\n\n      console.log(`Merging items from the network ${incoming.length}`);\n      console.log(incoming);\n      const merged = existing ? existing.slice(0) : [];\n      merged.push(incoming);\n\n      for (let i = skip; i < skip + incoming.length; ++i) {\n        merged[i] = incoming[i - skip];\n      }\n\n      console.log(merged); //Finally we return the merged items form the cache\n\n      return merged;\n    }\n\n  };\n}","map":{"version":3,"sources":["/home/avinash/Desktop/Projects/TheStore/frontend/lib/paginationField.js"],"names":["PAGINATION_QUERY","paginationField","keyArgs","read","existing","args","cache","console","log","skip","first","data","readQuery","query","count","_allProductsMeta","page","pages","Math","ceil","items","slice","filter","x","length","merge","incoming","merged","push","i"],"mappings":"AAAA,SAAQA,gBAAR,QAA+B,0BAA/B;AAEA,eAAgB,SAASC,eAAT,GAA0B;AACtC,SAAQ;AACJC,IAAAA,OAAO,EAAC,KADJ;;AACW;AACfC,IAAAA,IAAI,CAACC,QAAQ,GAAG,EAAZ,EAAe;AAACC,MAAAA,IAAD;AAAMC,MAAAA;AAAN,KAAf,EAA4B;AAAA;;AAC5BC,MAAAA,OAAO,CAACC,GAAR,CAAY;AAACJ,QAAAA,QAAD;AAAUC,QAAAA,IAAV;AAAeC,QAAAA;AAAf,OAAZ;AAEA,YAAM;AAAEG,QAAAA,IAAF;AAAQC,QAAAA;AAAR,UAAiBL,IAAvB,CAH4B,CAK5B;;AACA,YAAMM,IAAI,GAAGL,KAAK,CAACM,SAAN,CAAgB;AAACC,QAAAA,KAAK,EAACb;AAAP,OAAhB,CAAb;AACAO,MAAAA,OAAO,CAACC,GAAR,CAAYG,IAAZ;AACA,YAAMG,KAAK,GAAGH,IAAH,aAAGA,IAAH,gDAAGA,IAAI,CAAEI,gBAAT,0DAAG,sBAAwBD,KAAtC;AAEA,YAAME,IAAI,GAAGP,IAAI,GAACC,KAAL,GAAW,CAAxB;AAEA,YAAMO,KAAK,GAAGC,IAAI,CAACC,IAAL,CAAUL,KAAK,GAACJ,KAAhB,CAAd,CAZ4B,CAc5B;;AACA,YAAMU,KAAK,GAAGhB,QAAQ,CAACiB,KAAT,CAAeJ,KAAf,EAAsBR,IAAI,GAAGC,KAA7B,EAAoCY,MAApC,CAA4CC,CAAD,IAAMA,CAAjD,CAAd,CAf4B,CAiB5B;AACA;AACA;AACA;;AACA,UAAGH,KAAK,CAACI,MAAN,IAAgBJ,KAAK,CAACI,MAAN,KAAiBd,KAAjC,IAA0CM,IAAI,IAAIC,KAArD,EAA2D;AACvD,eAAOG,KAAP;AACH;;AAED,UAAGA,KAAK,CAACI,MAAN,KAAiBd,KAApB,EAA0B;AACtB;AACA,eAAO,KAAP;AACH,OA5B2B,CA8B5B;;;AACA,UAAGU,KAAK,CAACI,MAAT,EAAgB;AACV,iCAAwBJ,KAAK,CAACI,MAAO,iDAAvC;AACA,eAAOJ,KAAP;AACC;;AAGL,aAAO,KAAP,CArC4B,CAqCd;AAId;AAEA;AAEA;AAEA;AAEH,KAnDG;;AAoDJK,IAAAA,KAAK,CAACrB,QAAD,EAAUsB,QAAV,EAAmB;AAACrB,MAAAA;AAAD,KAAnB,EAA0B;AAC3B,YAAM;AAACI,QAAAA,IAAD;AAAOC,QAAAA;AAAP,UAAgBL,IAAtB,CAD2B,CAG3B;;AACAE,MAAAA,OAAO,CAACC,GAAR,CAAa,kCAAiCkB,QAAQ,CAACF,MAAO,EAA9D;AACAjB,MAAAA,OAAO,CAACC,GAAR,CAAYkB,QAAZ;AAEA,YAAMC,MAAM,GAAGvB,QAAQ,GAACA,QAAQ,CAACiB,KAAT,CAAe,CAAf,CAAD,GAAmB,EAA1C;AAEAM,MAAAA,MAAM,CAACC,IAAP,CAAYF,QAAZ;;AAEA,WAAI,IAAIG,CAAC,GAAGpB,IAAZ,EAAiBoB,CAAC,GAACpB,IAAI,GAACiB,QAAQ,CAACF,MAAjC,EAAwC,EAAEK,CAA1C,EAA4C;AACxCF,QAAAA,MAAM,CAACE,CAAD,CAAN,GAAYH,QAAQ,CAACG,CAAC,GAAGpB,IAAL,CAApB;AACH;;AAEDF,MAAAA,OAAO,CAACC,GAAR,CAAYmB,MAAZ,EAf2B,CAgB3B;;AAEA,aAAOA,MAAP;AACH;;AAvEG,GAAR;AAyEH","sourcesContent":["import {PAGINATION_QUERY} from '../components/Pagination';\n\nexport default  function paginationField(){\n    return  {\n        keyArgs:false, //tells apollo we will take care of everything\n        read(existing = [],{args,cache}){\n            console.log({existing,args,cache});\n\n            const { skip, first} = args;\n\n            //Read the number of items on the page fromt he cache\n            const data = cache.readQuery({query:PAGINATION_QUERY});\n            console.log(data);\n            const count = data?._allProductsMeta?.count;\n\n            const page = skip/first+1;\n\n            const pages = Math.ceil(count/first);\n\n            //Check if we existing items\n            const items = existing.slice(pages, skip + first).filter((x) =>x);\n\n            //if there are items\n            //and there are'nt enough items to satisfy how many were requested\n            //ANd we are on the last page\n            //Then just send it\n            if(items.length && items.length !== first && page == pages){\n                return items;\n            }\n            \n            if(items.length !== first){\n                //We don't have any items we must go to the network to fetch\n                return false;\n            }\n\n            //If there are items, just return from the cache, we don't need to go to the network\n            if(items.length){\n                (`console.log(There are ${items.length} items in the cache ! Gonna send them to Apollo`);\n                return items;\n                }\n\n\n            return false; //fallback to network\n\n\n\n            //First thing it does it asks the read function for those items\n\n            //We can either do one of two things\n\n            //First things we can do is return the items because they are already in the cache\n\n            //The other thing we can do is to return false from here,(network request)\n\n        },\n        merge(existing,incoming,{args}){\n            const {skip, first} = args;\n\n            //THis runs when the apollo client comes back from the network with our prouct\n            console.log(`Merging items from the network ${incoming.length}`);\n            console.log(incoming);\n\n            const merged = existing?existing.slice(0):[];\n\n            merged.push(incoming);\n\n            for(let i = skip;i<skip+incoming.length;++i){\n                merged[i] = incoming[i - skip];\n            }\n\n            console.log(merged);\n            //Finally we return the merged items form the cache\n\n            return merged;\n        }\n    }\n}"]},"metadata":{},"sourceType":"module"}